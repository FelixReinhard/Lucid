# Lucid Programming Language

An interpreted dynamically typed imperative programming Language written in Rust. It uses a stack-based virtual machine with a single pass compiler.

Most of the code was written while reading the book [crafting interpreters](craftinginterpreters.com/).

## Installation 
You can install the interpreter by building it from source. To do that, you need the [rust tool chain](https://www.rust-lang.org/tools/install). 
To check if you have everything installed correctly, try 
```shell
cargo --version 
``` 

Now first clone the repo: 
```shell
git clone https://github.com/FelixReinhard/Lucid.git
```
Then navigate into the folder and compile the code:
```shell
cd Lucid
cargo build --release
```
The executable can then be found in */target/release/*. Optionally put this file into your */bin/* folder or in any other folder in your $PATH

## Usage
To run a script, simply put the code in a file with the ending **.lucid**.
```shell
lucid <name>.lucid
```
To see all options, just write 
```shell
lucid 
```
For example, to see the generated bytecode type *--bytecode*.

## Syntax
The most fitting description of the syntax may be a mixture between rust and python.
Similar to python, all code is executed from top to bottom, so no *main* function is needed.
```rust
print("Hello World");
```
### Variables
The Language is dynamically typed, so when declaring variables, no type annotation is needed.
```rust
let integer = 42;
let string = "A String";
let float = 0.5;
let binary_number = 0b0011; // type=int
let hex_number = 0xff; // type=int
```
Every variable declared is mutable and can be reassigned with any type.
```rust
let x = 0;
x = "Now a String";
x += " and another";
print(x); // "Now a String and another"
```

### Functions
Functions are **first class objects** in Lucid and therefore can be passed around in variables. They are declared with the *fn* keyword and can take an arbitrary amount of arguments.
```rust 
fn a_function(arg1, arg2) {
  return arg1 + arg2;
}
let func = a_function;
print(func(10, 5)); // 15
```
The Function is followed by a block. If the function just needs to return an expression, one can use this syntax
```rust 
fn expression(a, b) => a + b;
// is semantically the same 
fn expression(a, b) {
  return a + b;
}
```
Like other dynamically typed Languages, Closures and expression based "lambda" functions are also available.
```rust
let f;
{
  let outside_var = "outside";
  f = fn () => print(outside_var);
}
f(); // "outside"
```

### Lists
The current List values are rather restrictive, but it is planned to expand on them in the *std*.
```rust
let numbers = [1, 2, 3, 4];
print(numbers[2]); // 3
numbers[3] = 2;
print(numbers); // [1, 2, 3, 2]
```
The elements of a list don't have to be any **specific type**.
```rust 
let different_types = ["a String", 42, 0.5];
```

### Loops and Conditionals 
As in any other imperative programming languages, there are loops and if statements.
A familiar While loop
```rust
while true => print("infinite loop");
```
And a for loop very similar to pythons for loop. Note that instead of an iterator, the for loop needs a list.
That's because Lucid has not built in iterators at the moment. This structure will simply expand to a corresponding while loop.
```rust
for i in [1, 2, 3] => print(i);
```

If statements are very close to rusts.
```rust
if 4 > 4.0 {
  print("hi");
} else {
  print("not here");
}
```
### Structs
Lucid is **not** an object-oriented Language, but has structs that work like structs in rust or go, meaning they can have methods. Their fields are not typed. A struct instance is created with the "new" keyword followed by the Name of the struct and optionally the initial values of the fields in order. Otherwise, the fields will all be assigned "null".
Methods can also be static, which is annotated by the "self" keyword in the argument list.
```rust 
struct Vec2{x, y}

// normal method 
fn Vec2::get_x(self) => self.x;
// static method
fn Vec2::create() => new Vec2(0, 0);

let vec = Vec2.create();
let x = vec.get_x();
print(x);

```
Note that if you would put the method **"create"** above **"get_x"**, the resulting instance would not have the method **"get_x"**. This is a problem at the moment, which will likely not be fixed, as this would require some fundamental changes to the compiler.  


### Imports 
Lastly, it is also possible to import other files. Semantically, this means the contents of the imported file is simply copied to this place, very much like the include of c. The import does not need a semicolon, but can be put there for aesthetic reasons.
```py
import file; // imports file.lucid
```

## Architecture, Performance and Problems.
The code is compiled into a *sort-of-bytecode*. This means not actual bytes are used but rust **enums**, this makes it very convenient to work with but is quite slow. The Stack based Vm also doesn't help with performance. In essence, this language is hilariously slow and could really use some optimizations or a whole rework of the vm. This will likely not happen, as this whole project was not an attempt to make a real language that other people could use, but rather a learning experience on how to do this. I highly recommend the [book](craftinginterpreters.com/) I read while making this. 

The biggest Problem though, that makes this language quite unusable are the **error messages**, or lack there of. So for me next time I need to focus heavily on making good error messages.

## Built in functions
Here is a list of all built in functions.
- `print(arg)` takes a values and prints it. Currently everything is printable.
- `read()` takes no arguments and returns input from the terminal.
- `len(list)` takes a list and returns its length 
- `range(number)` takes one integer **i** and returns a list from 0 to **i**. For example `range(4)` produces [0, 1, 2, 3]
- `sleep(ms)` takes one integer and sleeps for this amount of ms.
- `now()` takes no arguments and retunrs an integer representing the current time. for more info look into the file **vm/native.rs**
